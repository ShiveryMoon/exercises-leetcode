class Solution:
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        rl=[]
        m=len(board)
        if m==0:
            return True
        n=len(board[0])
        ds=[[-1,0],[0,1],[1,0],[0,-1]]
        visited=[[False for x in range(n)] for y in range(m)]
        for i in range(m):
            for j in range(n):
                if board[i][j]=='O' and not visited[i][j]:
                    tl=[]
                    self.floodfill(board,m,n,ds,visited,i,j,tl)
                    if False not in tl:
                        rl.append(tl)
        for region in rl:
            for x,y in region:
                board[x][y]='X'
            
    def inArea(self,x,y,m,n):
        return x>=0 and y>=0 and x<m and y<n
    
    def floodfill(self,board,m,n,ds,visited,startx,starty,tl):
        visited[startx][starty]=True
        tl.append((startx,starty))
        for i in range(4):
            newx=startx+ds[i][0]
            newy=starty+ds[i][1]
            if not self.inArea(newx,newy,m,n):
                tl.append(False)
                continue
            if board[newx][newy]=='O' and not visited[newx][newy]:
                self.floodfill(board,m,n,ds,visited,newx,newy,tl)
        
				
				
最长的测试用例过不了，栈溢出
        