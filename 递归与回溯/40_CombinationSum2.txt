class Solution:
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        candidates.sort()
        rl=[]
        self.backtracking(candidates,target,0,[],0,rl)
        return rl
    
    def backtracking(self,candidates,target,index,tl,sums,rl):
        if sums==target:
            rl.append(tl)
            return True
        while index<len(candidates):
            newSums=sums+candidates[index]
            if newSums<=target:
                sl=tl+[candidates[index]]
                self.backtracking(candidates,target,index+1,sl,newSums,rl)
            index+=1
            while index<len(candidates) and candidates[index-1]==candidates[index]:
                index+=1
				
先送进去一个，然后，把后面和这个值相等的都略过就行。
这个略过的过程发生在当前的while中就行

其实这个问题和combination sum 1的本质区别是：
我限定了每个元素的使用次数！每个元素的使用次数，就是这个元素的出现次数，其他都是一样的。
那道题需要去除冗余，同样的，这道题也需要去除冗余。
那道题，由于每个元素只出现一次，所以，我们用过哪个元素，就把他排除掉就好了。
可是在这道题中怎么排除已经用过的元素？假设我们这次用到了1，可是另一个1存不存在、存在的话在哪，我们都不知道，怎么去除？
所以必须先排序。