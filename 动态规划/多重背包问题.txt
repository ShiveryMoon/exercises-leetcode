多重背包问题同样有三种方法，硬生生拆成11111，拆成1248，或者直接优化成O(NC)
第一种太傻，第三种需要用单调队列优化，这里只讲第二种
方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。
使这些系数分别为 1,2,4,...,2^(k-1),n[i]+1-2^k，且k是满足n[i]+1-2^k>0的最大整数。
例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。
对于1到13的所有数字，均可由1,2,4,6其中的1个或多个数字求和而得到。
可以看出，解决多重背包的问题，只在于一个拆分函数，而这个拆分函数事实上是可以应用于大多数情况的，所以我直接尝试写一个拆分函数好了。

import math
def knapSplit(n,v,w):#物品序号就是索引，将新数据添加到列表末尾不仅效率高，也不会打乱索引。
    for i in range(len(n)):
        k=int(math.sqrt(n[i]))
        for j in range(1,k):#从1开始，因为本身v和w里就有1个i物品
            coe=2**j
            v.append(v[i]*coe)
            w.append(w[i]*coe)
        coe=n[i]+1-2**k
        v.append(v[i]*coe)
        w.append(w[i]*coe)
		
该函数运行完后，多重背包问题直接变成01背包问题，不多解释了。