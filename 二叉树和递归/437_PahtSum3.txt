class Solution:
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        if root is None:
            return 0
        return self.findPath(root,sum)+self.pathSum(root.left,sum)+self.pathSum(root.right,sum)
    
    def findPath(self,root,sum):
        if root is None:
            return 0
        res=0
        if root.val == sum:
            res+=1
        res+=self.findPath(root.left,sum-root.val)
        res+=self.findPath(root.right,sum-root.val)
        return res
		
注释接113
首先注意findPath的逻辑，它返回的是一个和，这个和返回之前先要拿到自己左右子树返回的值。
这是一个后序的逻辑。16 17行这个if写在19和20之间也没问题，并不影响它是一个后序的逻辑
所以这道题我们可以用return的方式来在函数之间交流信息。

但其实，这还是一个理解清楚函数具体功能的问题。
既然函数需要我们返回一个int，那就肯定要return。
不像113，只要对列表进行操作就行，它确实不需要return。

解决递归问题的最重要的一点还是要用清晰的思路构造自己的函数啊，要知道这个函数是干什么的，为什么它可以递归而不出错。